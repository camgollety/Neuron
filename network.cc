#include <iostream>
#include <cmath> 
#include <vector>
#include <cassert>
#include "network.hpp"

using namespace std; 


Network::Network() 
{
	for (int i(0); i<Const::NB_NEURONS; ++i) {
	neurons[i] =nullptr;
	} ///initialisation of the array of neurons that are pointers 
	
	for (auto line: connections_) {
		for (auto cas: line) {
			line[cas]=0;
			}};  ///initialisation of the matrix of connexion 
	
	///creation of the neurons 
	for (int i = 0; i < Const::NB_NEURONS; ++i) {
		neurons[i] = new Neuron();	
	}
	/// the first 10 000 neurons are excitatory and the others are inhibitory
	for (int j=0; j<Const::NB_EXCITATORY; ++j) {
		neurons[j]->setExcitatory(true);
	}
	
	///generating connections using uniformly distributed random numbers 
    random_device rd;
	mt19937 gen(rd());
	
	uniform_int_distribution<int> d1(0, Const::NB_EXCITATORY-1); 
	uniform_int_distribution<int> d2(Const::NB_EXCITATORY, Const::NB_NEURONS-1); 
	
	for (auto& neuron : connections_) {
		for (auto& cas : neuron) {
		
	for (int k(0); k<Const::C_EXCITATORY; ++k) {
		int n(d1(gen));
		if (n>0) {
		neuron[n]+=1; }  
	}
	
	for (int l(0); l<Const::C_INIBITORY; ++l) {
		int m(d2(gen));
		if (m>0) {
		neuron[m]+=1; }
	}
	}
}
}

Network::~Network() {
	for (auto& neuron : neurons) {
		delete neuron;
		neuron = nullptr;
	}
}

void Network::update(double I, int steps) 
{
	for (size_t i(0); i< neurons.size(); ++i) 
	{
		neurons[i]->setIext(I);
		neurons[i]->update(steps);		
		
		if (neurons[i]->spiked()) {
			cout << "The neuron spiked at : " << steps*Const::H << "ms: " << neurons[i]->getMemPot() << "mV"<< endl; 
			
			///transmission of the spike to other neurons 
			for(auto connected: connections_[i]) ///we go through the connexions of neuron i to transmit the signal 
			{ 
				if (i<Const::NB_EXCITATORY-1) {
				neurons[connected]->receive(Const::J_EXCITATORY, steps); }
				else {
					neurons[connected]->receive(Const::J_INHIBITORY, steps); 
			}
		}
	}
}
}


int Network::getNeuronClock(int i) const 
{
	return neurons[i]->getClock(); 
}

double Network::getBackGroundNoise() const{
		std::random_device rd; ///creation of a random device 
		
		std::mt19937 gen(rd()); ///initializing random generator 

		std::poisson_distribution<> Vext(Const::V_EXT * Const::C_EXCITATORY * Const::H * Const::J_EXCITATORY); ///initializing a poisson distribution 
		
		return Vext(gen);
} /** @return the value of Vext from the rest of the brain that is generated by poisson distribution **/
	
	
